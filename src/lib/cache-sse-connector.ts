// ‚úÖ SSE Connector para Cache Events em Tempo Real - TEMPORARILY DISABLED FOR PROJECT DELIVERY
/*
import { intelligentCache } from "./intelligent-cache";
*/

/*
interface CacheEvent {
  type: "invalidate" | "invalidate_type" | "update" | "delete";
  pattern: string;
  timestamp: string;
  metadata?: any;
}

export class CacheSSEConnector {
  private eventSource: EventSource | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private isConnected = false;
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private isConnecting = false; // ‚úÖ Prevenir m√∫ltiplas conex√µes simult√¢neas
  private isDisabled = false; // ‚úÖ Flag para desabilitar completamente

  // ‚úÖ Conectar ao SSE
  connect() {
    // ‚úÖ Verificar se est√° desabilitado
    if (this.isDisabled) {
      console.log("üö´ [CacheSSE] SSE desabilitado, ignorando conex√£o");
      return;
    }

    if (typeof window === "undefined") {
      console.log("üö´ [CacheSSE] Ambiente n√£o √© browser, ignorando conex√£o");
      return;
    }

    // ‚úÖ Prevenir m√∫ltiplas conex√µes simult√¢neas
    if (this.isConnecting || this.isConnected) {
      console.log(
        "üîÑ [CacheSSE] J√° conectando ou conectado, ignorando nova tentativa"
      );
      return;
    }

    // Verificar se usu√°rio est√° logado
    if (!this.isUserLoggedIn()) {
      console.log("üë§ [CacheSSE] Usu√°rio n√£o logado, n√£o conectando SSE");
      return;
    }

    try {
      this.isConnecting = true; // ‚úÖ Marcar como conectando

      console.log("üîå [CacheSSE] Iniciando conex√£o SSE...");
      console.log(
        `üìä [CacheSSE] Estado atual: conectado=${this.isConnected}, tentativas=${this.reconnectAttempts}`
      );

      // Construir URL com auth token via query parameter
      const token = this.getAuthToken();
      const API_BASE_URL = "https://api.expatriamente.com/api/v1";

      // Esta linha cria um novo objeto URL apontando para o endpoint "/cache-events/stream" usando a base da API definida em API_BASE_URL.
      // Ou seja, ela monta a URL completa para onde a conex√£o SSE ser√° aberta, por exemplo:
      // Se API_BASE_URL for "https://api.expatriamente.com/api/v1", o resultado ser√° "https://api.expatriamente.com/api/v1/cache-events/stream".
      const url = new URL(`${API_BASE_URL}/cache-events/stream`);
      // Adicionar token como query parameter
      if (token) {
        url.searchParams.append("token", token);
      }
      console.log("aAAAAAA URLLLLLLLLLLLLL", API_BASE_URL);
      console.log(`üåê [CacheSSE] URL de conex√£o: ${url.toString()}`);
      console.log(`üîë [CacheSSE] Token presente: ${!!token}`);

      // Criar EventSource
      // Nota: EventSource nativo n√£o suporta withCredentials, mas cookies HTTP-only
      // s√£o enviados automaticamente pelo navegador se o dom√≠nio for o mesmo
      this.eventSource = new EventSource(url.toString());

      console.log(`‚úÖ [CacheSSE] EventSource criado, configurando handlers...`);
      this.setupEventHandlers();
    } catch (error) {
      console.error("‚ùå [CacheSSE] Erro ao conectar:", error);
      this.isConnecting = false; // ‚úÖ Resetar flag de conex√£o
      this.handleReconnection();
    }
  }

  // ‚úÖ Configurar event handlers
  private setupEventHandlers() {
    if (!this.eventSource) return;

    this.eventSource.onopen = () => {
      console.log("‚úÖ [SSE] Conectado para atualiza√ß√µes em tempo real");
      this.isConnected = true;
      this.isConnecting = false; // ‚úÖ Resetar flag de conex√£o
      this.reconnectAttempts = 0;

      // Limpar timeout de reconex√£o se existir
      if (this.reconnectTimeout) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }

      // Emitir evento de conex√£o
      this.emitConnectionEvent("connected");
    };

    this.eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        // Filtrar heartbeat
        if (data.type === "heartbeat") {
          console.log("üíì [SSE] Heartbeat recebido");
          return;
        }

        console.log(`üì° [SSE] Evento recebido:`, data);
        this.handleCacheEvent(data);
      } catch (error) {
        console.error("‚ùå [SSE] Erro ao processar evento:", error);
      }
    };

    this.eventSource.onerror = (error) => {
      console.error("‚ùå [SSE] Erro na conex√£o:", error);
      this.isConnected = false;
      this.isConnecting = false; // ‚úÖ Resetar flag de conex√£o
      this.emitConnectionEvent("error");
      this.handleReconnection();
    };
  }

  // ‚úÖ Processar eventos de cache
  private async handleCacheEvent(event: CacheEvent) {
    try {
      console.log(`üéØ [CacheSSE] Processando evento de cache:`);
      console.log(
        `üìã [CacheSSE] Tipo: ${event.type}, Padr√£o: ${event.pattern}, Timestamp: ${event.timestamp}`
      );
      console.log(`üè∑Ô∏è [CacheSSE] Metadata:`, event.metadata);

      switch (event.type) {
        case "invalidate":
          console.log(
            `üîÑ [CacheSSE] Invalidando cache por padr√£o: ${event.pattern}`
          );
          await intelligentCache.invalidatePattern(event.pattern);
          console.log(
            `‚úÖ [CacheSSE] Cache invalidado com sucesso: ${event.pattern}`
          );
          break;

        case "invalidate_type":
          console.log(
            `üîÑ [CacheSSE] Invalidando cache por tipo: ${event.pattern}`
          );
          await intelligentCache.invalidateByType(event.pattern as any);
          console.log(
            `‚úÖ [CacheSSE] Tipo de cache invalidado com sucesso: ${event.pattern}`
          );
          break;

        case "update":
          console.log(`üîÑ [CacheSSE] Cache atualizado: ${event.pattern}`);
          console.log(
            `‚ÑπÔ∏è [CacheSSE] Implementa√ß√£o espec√≠fica de atualiza√ß√£o pode ser adicionada aqui`
          );
          break;

        case "delete":
          console.log(`üóëÔ∏è [CacheSSE] Deletando cache: ${event.pattern}`);
          await intelligentCache.delete(event.pattern);
          console.log(
            `‚úÖ [CacheSSE] Cache deletado com sucesso: ${event.pattern}`
          );
          break;

        default:
          console.warn(
            `‚ö†Ô∏è [CacheSSE] Tipo de evento desconhecido: ${event.type}`
          );
      }

      // Emitir evento customizado para componentes
      console.log(`üì° [CacheSSE] Notificando componentes sobre atualiza√ß√£o...`);
      this.notifyComponentUpdate(event);
      console.log(`‚úÖ [CacheSSE] Componentes notificados com sucesso`);
    } catch (error) {
      console.error(`‚ùå [CacheSSE] Erro ao processar evento de cache:`, error);
      console.error(`üîç [CacheSSE] Detalhes do evento que falhou:`, event);
    }
  }

  // ‚úÖ Notificar componentes sobre atualiza√ß√£o
  private notifyComponentUpdate(event: CacheEvent) {
    const customEvent = new CustomEvent("cache-updated", {
      detail: {
        type: event.type,
        pattern: event.pattern,
        timestamp: event.timestamp,
        metadata: event.metadata,
      },
    });

    window.dispatchEvent(customEvent);

    // Tamb√©m emitir evento espec√≠fico por tipo
    const typeEvent = new CustomEvent(`cache-${event.type}`, {
      detail: {
        pattern: event.pattern,
        timestamp: event.timestamp,
        metadata: event.metadata,
      },
    });

    window.dispatchEvent(typeEvent);
  }

  // ‚úÖ Emitir eventos de conex√£o
  private emitConnectionEvent(
    status: "connected" | "disconnected" | "error" | "reconnecting"
  ) {
    const connectionEvent = new CustomEvent("sse-connection-change", {
      detail: {
        status,
        timestamp: new Date().toISOString(),
        attempts: this.reconnectAttempts,
      },
    });

    window.dispatchEvent(connectionEvent);
  }

  // ‚úÖ Lidar com reconex√£o
  private handleReconnection() {
    // ‚úÖ Verificar se est√° desabilitado
    if (this.isDisabled) {
      console.log("üö´ [SSE] SSE desabilitado, n√£o tentando reconectar");
      return;
    }

    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error(
        `‚ùå [SSE] M√°ximo de tentativas de reconex√£o atingido (${this.maxReconnectAttempts})`
      );
      this.emitConnectionEvent("error");
      this.isDisabled = true; // ‚úÖ Desabilitar ap√≥s m√°ximo de tentativas
      return;
    }

    this.reconnectAttempts++;
    const delay = Math.min(Math.pow(2, this.reconnectAttempts) * 1000, 30000); // M√°ximo 30s

    console.log(
      `üîÑ [SSE] Tentativa de reconex√£o ${this.reconnectAttempts} em ${delay}ms`
    );
    this.emitConnectionEvent("reconnecting");

    this.reconnectTimeout = setTimeout(() => {
      this.disconnect(false); // N√£o emitir evento de desconex√£o
      this.connect();
    }, delay);
  }

  // ‚úÖ Desconectar
  disconnect(emitEvent = true) {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    this.isConnected = false;
    this.isConnecting = false; // ‚úÖ Resetar flag de conex√£o
    this.reconnectAttempts = 0;

    if (emitEvent) {
      console.log("‚ùå [SSE] Desconectado");
      this.emitConnectionEvent("disconnected");
    }
  }

  // ‚úÖ Verificar se usu√°rio est√° logado
  private isUserLoggedIn(): boolean {
    try {
      const token =
        localStorage.getItem("auth_token") ||
        sessionStorage.getItem("auth_token");
      return !!token;
    } catch (error) {
      return false;
    }
  }

  // ‚úÖ Obter token de autentica√ß√£o
  private getAuthToken(): string | null {
    try {
      return (
        localStorage.getItem("auth_token") ||
        sessionStorage.getItem("auth_token")
      );
    } catch (error) {
      return null;
    }
  }

  // ‚úÖ Verificar status da conex√£o
  getConnectionStatus(): {
    isConnected: boolean;
    reconnectAttempts: number;
    readyState?: number;
  } {
    return {
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
      readyState: this.eventSource?.readyState,
    };
  }

  // ‚úÖ For√ßar reconex√£o
  forceReconnect() {
    console.log("üîÑ [SSE] For√ßando reconex√£o...");
    this.disconnect(false);
    this.reconnectAttempts = 0;
    this.isDisabled = false; // ‚úÖ Reabilitar se estava desabilitado
    this.connect();
  }

  // ‚úÖ Habilitar/Desabilitar SSE
  enable() {
    console.log("‚úÖ [SSE] Habilitando SSE...");
    this.isDisabled = false;
  }

  disable() {
    console.log("üö´ [SSE] Desabilitando SSE...");
    this.isDisabled = true;
    this.disconnect(false);
  }
}

// Inst√¢ncia global
export const cacheSSE = new CacheSSEConnector();
}
*/

// ‚úÖ TEMPORARY FALLBACK IMPLEMENTATION FOR PROJECT DELIVERY
export class CacheSSEConnector {
  connect() {
    console.log(
      "‚ö†Ô∏è [SSE] Desabilitado temporariamente para entrega do projeto"
    );
  }

  disconnect(emitEvent = true) {
    console.log(
      "‚ö†Ô∏è [SSE] Desabilitado temporariamente para entrega do projeto"
    );
  }

  getConnectionStatus() {
    return {
      isConnected: false,
      reconnectAttempts: 0,
      readyState: 0,
    };
  }

  forceReconnect() {
    console.log(
      "‚ö†Ô∏è [SSE] Desabilitado temporariamente para entrega do projeto"
    );
  }

  enable() {
    console.log(
      "‚ö†Ô∏è [SSE] Desabilitado temporariamente para entrega do projeto"
    );
  }

  disable() {
    console.log(
      "‚ö†Ô∏è [SSE] Desabilitado temporariamente para entrega do projeto"
    );
  }
}

// Inst√¢ncia global
export const cacheSSE = new CacheSSEConnector();

// ‚úÖ Auto-conectar quando poss√≠vel - TEMPORARILY DISABLED FOR PROJECT DELIVERY
/*
if (typeof window !== "undefined") {
  // Conectar ap√≥s login
  window.addEventListener("storage", (event) => {
    if (event.key === "auth_token" && event.newValue) {
      console.log("üîë [SSE] Token detectado, conectando...");
      setTimeout(() => cacheSSE.connect(), 1000);
    } else if (event.key === "auth_token" && !event.newValue) {
      console.log("üö™ [SSE] Logout detectado, desconectando...");
      cacheSSE.disconnect();
    }
  });

  // Reconectar quando a p√°gina ganhar foco
  window.addEventListener("focus", () => {
    const status = cacheSSE.getConnectionStatus();
    if (!status.isConnected && cacheSSE["isUserLoggedIn"]()) {
      console.log("üëÄ [SSE] P√°gina em foco, verificando conex√£o...");
      setTimeout(() => cacheSSE.forceReconnect(), 500);
    }
  });

  // Desconectar quando a p√°gina perder foco (opcional)
  window.addEventListener("beforeunload", () => {
    cacheSSE.disconnect(false);
  });
}
*/
